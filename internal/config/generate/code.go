// (c) Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: Apache-2.0 (see LICENSE)

package main

import (
	"bytes"
	"go/format"
	"os"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// Template function map
var funcMap = template.FuncMap{
	// toFieldName converts an env var name like "CARTESI_BLOCKCHAIN_DEFAULT_BLOCK"
	// into a Go-friendly field name like "BlockchainDefaultBlock".
	"toFieldName": func(env string) string {
		caser := cases.Title(language.English)
		words := strings.FieldsFunc(env, func(r rune) bool {
			return r == '_'
		})
		// Optionally remove a common prefix (e.g. "CARTESI")
		if len(words) > 1 && words[0] == "CARTESI" {
			words = words[1:]
		}
		for i, word := range words {
			words[i] = caser.String(strings.ToLower(word))
		}
		return strings.Join(words, "")
	},
	"toConstName": func(s string) string {
		return strings.TrimPrefix(s, "CARTESI_")
	},
	"hasPrefix": func(prefix, s string) bool {
		return strings.HasPrefix(s, prefix)
	},
	// defaultVal returns the dereferenced default value or an empty string.
	"defaultVal": func(s *string) string {
		if s == nil {
			return ""
		}
		return *s
	},
	// toGoFunc returns the conversion function name.
	"toGoFunc": func(goType string) string {
		// For example, "int" becomes "toInt", "Duration" becomes "toDuration".
		return "to" + strings.ToUpper(goType[:1]) + goType[1:]
	},
	// splitLines splits a string into lines (by "\n").
	"splitLines": func(s string) []string {
		return strings.Split(s, "\n")
	},
	"mapstructure": func(s string) string {
		return "`mapstructure:\"" + s + "\"`"
	},
}

// generateCodeFile renders the template with the given Env slice and writes it to the specified file.
func generateCodeFile(path string, envs []Env) {
	tmpl := template.Must(template.New("code").Funcs(funcMap).Parse(codeTemplate))
	var buff bytes.Buffer
	if err := tmpl.Execute(&buff, envs); err != nil {
		panic(err)
	}
	code, err := format.Source(buff.Bytes())
	if err != nil {
		panic(err)
	}
	if err := os.WriteFile(path, code, 0644); err != nil {
		panic(err)
	}
}

// The template for the generated code
const codeTemplate = `// Code generated by internal/config/generate.
// DO NOT EDIT.
//
// (c) Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: Apache-2.0 (see LICENSE)

package config

import (
	"fmt"

	"github.com/spf13/viper"
)

var ErrNotDefined = fmt.Errorf("variable not defined")

func init() {
    // Automatically bind environment variables.
    viper.AutomaticEnv()
}

const (
{{ range . -}}
	{{ toConstName .Name }} = "{{ .Name }}"
{{ end -}}
)

// Config holds all configuration values.
type Config struct {
{{ range . }}
{{ if not .Omit -}}
{{ if .Description -}}
{{ range $line := splitLines .Description -}}
	// {{ $line }}
{{ end -}}
{{ end -}}
	{{ toFieldName .Name }} {{ .GoType }} {{ mapstructure .Name }}
{{ end -}}
{{ end }}
}

func SetDefaults() {
	// Set defaults based on the TOML definitions.
{{ range . }}
{{ if .Default }}	viper.SetDefault({{ toConstName .Name }}, "{{ defaultVal .Default }}")
{{ else }}	// no default for {{ .Name }}
{{ end }}
{{ end }}
}

// Load reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func Load() (*Config, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg Config
	var err error
	// For each env, perform conversion using the appropriate conversion function.
{{ range . }}
{{ if not .Omit -}}
	cfg.{{ toFieldName .Name }}, err = Get{{ toFieldName .Name }}()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}
{{ end -}}
{{ end -}}

	return &cfg, nil
}

{{ range . }}
// Get{{ toFieldName .Name }} returns the value for the environment variable {{ .Name }}.
func Get{{ toFieldName .Name }}() ({{ .GoType }}, error) {
	s := viper.GetString({{ toConstName .Name }})
	if s != "" {
		v, err := {{ toGoFunc .GoType }}(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", {{ toConstName .Name }}, err)
		}
		return v, nil
	}
	return notDefined{{ .GoType }}(), fmt.Errorf("%s: %w", {{ toConstName .Name }}, ErrNotDefined)
}
{{ end }}

`

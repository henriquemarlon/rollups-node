// Code generated by internal/config/generate.
// DO NOT EDIT.
//
// (c) Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: Apache-2.0 (see LICENSE)

package config

import (
	"fmt"

	"github.com/spf13/viper"
)

var ErrNotDefined = fmt.Errorf("variable not defined")

func init() {
	// Automatically bind environment variables.
	viper.AutomaticEnv()
}

const (
	AUTH_AWS_KMS_KEY_ID                               = "CARTESI_AUTH_AWS_KMS_KEY_ID"
	AUTH_AWS_KMS_REGION                               = "CARTESI_AUTH_AWS_KMS_REGION"
	AUTH_KIND                                         = "CARTESI_AUTH_KIND"
	AUTH_MNEMONIC                                     = "CARTESI_AUTH_MNEMONIC"
	AUTH_MNEMONIC_ACCOUNT_INDEX                       = "CARTESI_AUTH_MNEMONIC_ACCOUNT_INDEX"
	AUTH_MNEMONIC_FILE                                = "CARTESI_AUTH_MNEMONIC_FILE"
	AUTH_PRIVATE_KEY                                  = "CARTESI_AUTH_PRIVATE_KEY"
	AUTH_PRIVATE_KEY_FILE                             = "CARTESI_AUTH_PRIVATE_KEY_FILE"
	BLOCKCHAIN_DEFAULT_BLOCK                          = "CARTESI_BLOCKCHAIN_DEFAULT_BLOCK"
	BLOCKCHAIN_HTTP_ENDPOINT                          = "CARTESI_BLOCKCHAIN_HTTP_ENDPOINT"
	BLOCKCHAIN_ID                                     = "CARTESI_BLOCKCHAIN_ID"
	BLOCKCHAIN_LEGACY_ENABLED                         = "CARTESI_BLOCKCHAIN_LEGACY_ENABLED"
	BLOCKCHAIN_SUBSCRIPTION_TIMEOUT                   = "CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT"
	BLOCKCHAIN_WS_ENDPOINT                            = "CARTESI_BLOCKCHAIN_WS_ENDPOINT"
	CONTRACTS_APPLICATION_FACTORY_ADDRESS             = "CARTESI_CONTRACTS_APPLICATION_FACTORY_ADDRESS"
	CONTRACTS_AUTHORITY_FACTORY_ADDRESS               = "CARTESI_CONTRACTS_AUTHORITY_FACTORY_ADDRESS"
	CONTRACTS_INPUT_BOX_ADDRESS                       = "CARTESI_CONTRACTS_INPUT_BOX_ADDRESS"
	CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS = "CARTESI_CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS"
	DATABASE_CONNECTION                               = "CARTESI_DATABASE_CONNECTION"
	FEATURE_CLAIM_SUBMISSION_ENABLED                  = "CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED"
	FEATURE_INPUT_READER_ENABLED                      = "CARTESI_FEATURE_INPUT_READER_ENABLED"
	FEATURE_INSPECT_ENABLED                           = "CARTESI_FEATURE_INSPECT_ENABLED"
	FEATURE_JSONRPC_API_ENABLED                       = "CARTESI_FEATURE_JSONRPC_API_ENABLED"
	FEATURE_MACHINE_HASH_CHECK_ENABLED                = "CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED"
	INSPECT_ADDRESS                                   = "CARTESI_INSPECT_ADDRESS"
	JSONRPC_API_ADDRESS                               = "CARTESI_JSONRPC_API_ADDRESS"
	TELEMETRY_ADDRESS                                 = "CARTESI_TELEMETRY_ADDRESS"
	LOG_COLOR                                         = "CARTESI_LOG_COLOR"
	LOG_LEVEL                                         = "CARTESI_LOG_LEVEL"
	REMOTE_MACHINE_LOG_LEVEL                          = "CARTESI_REMOTE_MACHINE_LOG_LEVEL"
	ADVANCER_POLLING_INTERVAL                         = "CARTESI_ADVANCER_POLLING_INTERVAL"
	BLOCKCHAIN_HTTP_MAX_RETRIES                       = "CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES"
	BLOCKCHAIN_HTTP_RETRY_MAX_WAIT                    = "CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT"
	BLOCKCHAIN_HTTP_RETRY_MIN_WAIT                    = "CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT"
	CLAIMER_POLLING_INTERVAL                          = "CARTESI_CLAIMER_POLLING_INTERVAL"
	MAX_STARTUP_TIME                                  = "CARTESI_MAX_STARTUP_TIME"
	VALIDATOR_POLLING_INTERVAL                        = "CARTESI_VALIDATOR_POLLING_INTERVAL"
	SNAPSHOT_DIR                                      = "CARTESI_SNAPSHOT_DIR"
)

func SetDefaults() {
	// Set defaults based on the TOML definitions.

	// no default for CARTESI_AUTH_AWS_KMS_KEY_ID

	// no default for CARTESI_AUTH_AWS_KMS_REGION

	viper.SetDefault(AUTH_KIND, "mnemonic")

	// no default for CARTESI_AUTH_MNEMONIC

	viper.SetDefault(AUTH_MNEMONIC_ACCOUNT_INDEX, "0")

	// no default for CARTESI_AUTH_MNEMONIC_FILE

	// no default for CARTESI_AUTH_PRIVATE_KEY

	// no default for CARTESI_AUTH_PRIVATE_KEY_FILE

	viper.SetDefault(BLOCKCHAIN_DEFAULT_BLOCK, "finalized")

	// no default for CARTESI_BLOCKCHAIN_HTTP_ENDPOINT

	// no default for CARTESI_BLOCKCHAIN_ID

	viper.SetDefault(BLOCKCHAIN_LEGACY_ENABLED, "false")

	viper.SetDefault(BLOCKCHAIN_SUBSCRIPTION_TIMEOUT, "60")

	// no default for CARTESI_BLOCKCHAIN_WS_ENDPOINT

	// no default for CARTESI_CONTRACTS_APPLICATION_FACTORY_ADDRESS

	// no default for CARTESI_CONTRACTS_AUTHORITY_FACTORY_ADDRESS

	// no default for CARTESI_CONTRACTS_INPUT_BOX_ADDRESS

	// no default for CARTESI_CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS

	viper.SetDefault(DATABASE_CONNECTION, "")

	viper.SetDefault(FEATURE_CLAIM_SUBMISSION_ENABLED, "true")

	viper.SetDefault(FEATURE_INPUT_READER_ENABLED, "true")

	viper.SetDefault(FEATURE_INSPECT_ENABLED, "true")

	viper.SetDefault(FEATURE_JSONRPC_API_ENABLED, "true")

	viper.SetDefault(FEATURE_MACHINE_HASH_CHECK_ENABLED, "true")

	viper.SetDefault(INSPECT_ADDRESS, ":10012")

	viper.SetDefault(JSONRPC_API_ADDRESS, ":10011")

	// no default for CARTESI_TELEMETRY_ADDRESS

	viper.SetDefault(LOG_COLOR, "true")

	viper.SetDefault(LOG_LEVEL, "info")

	viper.SetDefault(REMOTE_MACHINE_LOG_LEVEL, "info")

	viper.SetDefault(ADVANCER_POLLING_INTERVAL, "3")

	viper.SetDefault(BLOCKCHAIN_HTTP_MAX_RETRIES, "4")

	viper.SetDefault(BLOCKCHAIN_HTTP_RETRY_MAX_WAIT, "60")

	viper.SetDefault(BLOCKCHAIN_HTTP_RETRY_MIN_WAIT, "1")

	viper.SetDefault(CLAIMER_POLLING_INTERVAL, "3")

	viper.SetDefault(MAX_STARTUP_TIME, "15")

	viper.SetDefault(VALIDATOR_POLLING_INTERVAL, "3")

	viper.SetDefault(SNAPSHOT_DIR, "/var/lib/cartesi-rollups-node/snapshots")

}

// AdvancerConfig holds configuration values for the advancer service.
type AdvancerConfig struct {

	// Postgres endpoint in the 'postgres://user:password@hostname:port/database' format (URL).
	//
	// If not set, or set to empty string, will defer the behaviour to the PG driver.
	// See [this](https://www.postgresql.org/docs/current/libpq-envars.html) for more information.
	//
	// It is also possible to set the endpoint without a password and load it from Postgres' passfile.
	// See [this](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-PASSFILE)
	// for more information.
	DatabaseConnection URL `mapstructure:"CARTESI_DATABASE_CONNECTION"`

	// If set to false, the node will not start the inspect service.
	FeatureInspectEnabled bool `mapstructure:"CARTESI_FEATURE_INSPECT_ENABLED"`

	// If set to false, the node will *not* check whether the Cartesi machine hash from
	// the snapshot matches the hash in the Application contract.
	FeatureMachineHashCheckEnabled bool `mapstructure:"CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED"`

	// HTTP address for inspect.
	InspectAddress string `mapstructure:"CARTESI_INSPECT_ADDRESS"`

	// HTTP address for telemetry service.
	TelemetryAddress string `mapstructure:"CARTESI_TELEMETRY_ADDRESS"`

	// If set to true, the node will add colors to its log output.
	LogColor bool `mapstructure:"CARTESI_LOG_COLOR"`

	// One of "debug", "info", "warn", "error".
	LogLevel LogLevel `mapstructure:"CARTESI_LOG_LEVEL"`

	// Remote Cartesi Machine server log level.
	// One of "trace", "debug", "info", "warning", "error", "fatal".
	RemoteMachineLogLevel MachineLogLevel `mapstructure:"CARTESI_REMOTE_MACHINE_LOG_LEVEL"`

	// How many seconds the node will wait before querying the database for new inputs.
	AdvancerPollingInterval Duration `mapstructure:"CARTESI_ADVANCER_POLLING_INTERVAL"`

	// How many seconds the node expects services take initializing before aborting.
	MaxStartupTime Duration `mapstructure:"CARTESI_MAX_STARTUP_TIME"`

	// Path to the directory where the snapshots will be written.
	SnapshotDir string `mapstructure:"CARTESI_SNAPSHOT_DIR"`
}

// LoadAdvancerConfig reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func LoadAdvancerConfig() (*AdvancerConfig, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg AdvancerConfig
	var err error

	cfg.DatabaseConnection, err = GetDatabaseConnection()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_DATABASE_CONNECTION: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_DATABASE_CONNECTION is required for the advancer service: %w", err)
	}

	cfg.FeatureInspectEnabled, err = GetFeatureInspectEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_INSPECT_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_INSPECT_ENABLED is required for the advancer service: %w", err)
	}

	cfg.FeatureMachineHashCheckEnabled, err = GetFeatureMachineHashCheckEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED is required for the advancer service: %w", err)
	}

	cfg.InspectAddress, err = GetInspectAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_INSPECT_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_INSPECT_ADDRESS is required for the advancer service: %w", err)
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_TELEMETRY_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_TELEMETRY_ADDRESS is required for the advancer service: %w", err)
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_COLOR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_COLOR is required for the advancer service: %w", err)
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_LEVEL is required for the advancer service: %w", err)
	}

	cfg.RemoteMachineLogLevel, err = GetRemoteMachineLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_REMOTE_MACHINE_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_REMOTE_MACHINE_LOG_LEVEL is required for the advancer service: %w", err)
	}

	cfg.AdvancerPollingInterval, err = GetAdvancerPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_ADVANCER_POLLING_INTERVAL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_ADVANCER_POLLING_INTERVAL is required for the advancer service: %w", err)
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_MAX_STARTUP_TIME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_MAX_STARTUP_TIME is required for the advancer service: %w", err)
	}

	cfg.SnapshotDir, err = GetSnapshotDir()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_SNAPSHOT_DIR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_SNAPSHOT_DIR is required for the advancer service: %w", err)
	}

	return &cfg, nil
}

// ClaimerConfig holds configuration values for the claimer service.
type ClaimerConfig struct {

	// The default block to be used by EVM Reader and Claimer when requesting new blocks.
	// One of 'latest', 'pending', 'safe', 'finalized'
	BlockchainDefaultBlock DefaultBlock `mapstructure:"CARTESI_BLOCKCHAIN_DEFAULT_BLOCK"`

	// HTTP endpoint for the blockchain RPC provider.
	BlockchainHttpEndpoint URL `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_ENDPOINT"`

	// An unique identifier representing a blockchain network.
	BlockchainId uint64 `mapstructure:"CARTESI_BLOCKCHAIN_ID"`

	// If set to true the node will send transactions using the legacy gas fee model
	// (instead of EIP-1559).
	BlockchainLegacyEnabled bool `mapstructure:"CARTESI_BLOCKCHAIN_LEGACY_ENABLED"`

	// Postgres endpoint in the 'postgres://user:password@hostname:port/database' format (URL).
	//
	// If not set, or set to empty string, will defer the behaviour to the PG driver.
	// See [this](https://www.postgresql.org/docs/current/libpq-envars.html) for more information.
	//
	// It is also possible to set the endpoint without a password and load it from Postgres' passfile.
	// See [this](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-PASSFILE)
	// for more information.
	DatabaseConnection URL `mapstructure:"CARTESI_DATABASE_CONNECTION"`

	// If set to false, the node will not submit claims (reader mode).
	FeatureClaimSubmissionEnabled bool `mapstructure:"CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED"`

	// HTTP address for telemetry service.
	TelemetryAddress string `mapstructure:"CARTESI_TELEMETRY_ADDRESS"`

	// If set to true, the node will add colors to its log output.
	LogColor bool `mapstructure:"CARTESI_LOG_COLOR"`

	// One of "debug", "info", "warn", "error".
	LogLevel LogLevel `mapstructure:"CARTESI_LOG_LEVEL"`

	// Maximum number of retry attempts for HTTP blockchain requests after encountering an error.
	BlockchainHttpMaxRetries uint64 `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES"`

	// Maximum wait time in seconds for the exponential backoff retry policy. The delay between retries for HTTP blockchain requests will never exceed this value, regardless of the backoff calculation.
	BlockchainHttpRetryMaxWait Duration `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT"`

	// Minimum wait time in seconds for the exponential backoff retry policy. This is the initial delay before the first retry for HTTP blockchain requests.
	BlockchainHttpRetryMinWait Duration `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT"`

	// How many seconds the node will wait before querying the database for new claims.
	ClaimerPollingInterval Duration `mapstructure:"CARTESI_CLAIMER_POLLING_INTERVAL"`

	// How many seconds the node expects services take initializing before aborting.
	MaxStartupTime Duration `mapstructure:"CARTESI_MAX_STARTUP_TIME"`
}

// LoadClaimerConfig reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func LoadClaimerConfig() (*ClaimerConfig, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg ClaimerConfig
	var err error

	cfg.BlockchainDefaultBlock, err = GetBlockchainDefaultBlock()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_DEFAULT_BLOCK: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_DEFAULT_BLOCK is required for the claimer service: %w", err)
	}

	cfg.BlockchainHttpEndpoint, err = GetBlockchainHttpEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_ENDPOINT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_ENDPOINT is required for the claimer service: %w", err)
	}

	cfg.BlockchainId, err = GetBlockchainId()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_ID: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_ID is required for the claimer service: %w", err)
	}

	cfg.BlockchainLegacyEnabled, err = GetBlockchainLegacyEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_LEGACY_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_LEGACY_ENABLED is required for the claimer service: %w", err)
	}

	cfg.DatabaseConnection, err = GetDatabaseConnection()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_DATABASE_CONNECTION: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_DATABASE_CONNECTION is required for the claimer service: %w", err)
	}

	cfg.FeatureClaimSubmissionEnabled, err = GetFeatureClaimSubmissionEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED is required for the claimer service: %w", err)
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_TELEMETRY_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_TELEMETRY_ADDRESS is required for the claimer service: %w", err)
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_COLOR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_COLOR is required for the claimer service: %w", err)
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_LEVEL is required for the claimer service: %w", err)
	}

	cfg.BlockchainHttpMaxRetries, err = GetBlockchainHttpMaxRetries()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES is required for the claimer service: %w", err)
	}

	cfg.BlockchainHttpRetryMaxWait, err = GetBlockchainHttpRetryMaxWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT is required for the claimer service: %w", err)
	}

	cfg.BlockchainHttpRetryMinWait, err = GetBlockchainHttpRetryMinWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT is required for the claimer service: %w", err)
	}

	cfg.ClaimerPollingInterval, err = GetClaimerPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_CLAIMER_POLLING_INTERVAL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_CLAIMER_POLLING_INTERVAL is required for the claimer service: %w", err)
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_MAX_STARTUP_TIME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_MAX_STARTUP_TIME is required for the claimer service: %w", err)
	}

	return &cfg, nil
}

// EvmreaderConfig holds configuration values for the evmreader service.
type EvmreaderConfig struct {

	// The default block to be used by EVM Reader and Claimer when requesting new blocks.
	// One of 'latest', 'pending', 'safe', 'finalized'
	BlockchainDefaultBlock DefaultBlock `mapstructure:"CARTESI_BLOCKCHAIN_DEFAULT_BLOCK"`

	// HTTP endpoint for the blockchain RPC provider.
	BlockchainHttpEndpoint URL `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_ENDPOINT"`

	// An unique identifier representing a blockchain network.
	BlockchainId uint64 `mapstructure:"CARTESI_BLOCKCHAIN_ID"`

	// Block subscription timeout in seconds.
	BlockchainSubscriptionTimeout uint64 `mapstructure:"CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT"`

	// WebSocket endpoint for the blockchain RPC provider.
	BlockchainWsEndpoint URL `mapstructure:"CARTESI_BLOCKCHAIN_WS_ENDPOINT"`

	// Postgres endpoint in the 'postgres://user:password@hostname:port/database' format (URL).
	//
	// If not set, or set to empty string, will defer the behaviour to the PG driver.
	// See [this](https://www.postgresql.org/docs/current/libpq-envars.html) for more information.
	//
	// It is also possible to set the endpoint without a password and load it from Postgres' passfile.
	// See [this](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-PASSFILE)
	// for more information.
	DatabaseConnection URL `mapstructure:"CARTESI_DATABASE_CONNECTION"`

	// If set to false, the node will not read inputs from the blockchain.
	FeatureInputReaderEnabled bool `mapstructure:"CARTESI_FEATURE_INPUT_READER_ENABLED"`

	// HTTP address for telemetry service.
	TelemetryAddress string `mapstructure:"CARTESI_TELEMETRY_ADDRESS"`

	// If set to true, the node will add colors to its log output.
	LogColor bool `mapstructure:"CARTESI_LOG_COLOR"`

	// One of "debug", "info", "warn", "error".
	LogLevel LogLevel `mapstructure:"CARTESI_LOG_LEVEL"`

	// Maximum number of retry attempts for HTTP blockchain requests after encountering an error.
	BlockchainHttpMaxRetries uint64 `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES"`

	// Maximum wait time in seconds for the exponential backoff retry policy. The delay between retries for HTTP blockchain requests will never exceed this value, regardless of the backoff calculation.
	BlockchainHttpRetryMaxWait Duration `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT"`

	// Minimum wait time in seconds for the exponential backoff retry policy. This is the initial delay before the first retry for HTTP blockchain requests.
	BlockchainHttpRetryMinWait Duration `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT"`

	// How many seconds the node expects services take initializing before aborting.
	MaxStartupTime Duration `mapstructure:"CARTESI_MAX_STARTUP_TIME"`
}

// LoadEvmreaderConfig reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func LoadEvmreaderConfig() (*EvmreaderConfig, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg EvmreaderConfig
	var err error

	cfg.BlockchainDefaultBlock, err = GetBlockchainDefaultBlock()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_DEFAULT_BLOCK: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_DEFAULT_BLOCK is required for the evmreader service: %w", err)
	}

	cfg.BlockchainHttpEndpoint, err = GetBlockchainHttpEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_ENDPOINT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_ENDPOINT is required for the evmreader service: %w", err)
	}

	cfg.BlockchainId, err = GetBlockchainId()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_ID: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_ID is required for the evmreader service: %w", err)
	}

	cfg.BlockchainSubscriptionTimeout, err = GetBlockchainSubscriptionTimeout()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT is required for the evmreader service: %w", err)
	}

	cfg.BlockchainWsEndpoint, err = GetBlockchainWsEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_WS_ENDPOINT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_WS_ENDPOINT is required for the evmreader service: %w", err)
	}

	cfg.DatabaseConnection, err = GetDatabaseConnection()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_DATABASE_CONNECTION: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_DATABASE_CONNECTION is required for the evmreader service: %w", err)
	}

	cfg.FeatureInputReaderEnabled, err = GetFeatureInputReaderEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_INPUT_READER_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_INPUT_READER_ENABLED is required for the evmreader service: %w", err)
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_TELEMETRY_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_TELEMETRY_ADDRESS is required for the evmreader service: %w", err)
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_COLOR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_COLOR is required for the evmreader service: %w", err)
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_LEVEL is required for the evmreader service: %w", err)
	}

	cfg.BlockchainHttpMaxRetries, err = GetBlockchainHttpMaxRetries()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES is required for the evmreader service: %w", err)
	}

	cfg.BlockchainHttpRetryMaxWait, err = GetBlockchainHttpRetryMaxWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT is required for the evmreader service: %w", err)
	}

	cfg.BlockchainHttpRetryMinWait, err = GetBlockchainHttpRetryMinWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT is required for the evmreader service: %w", err)
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_MAX_STARTUP_TIME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_MAX_STARTUP_TIME is required for the evmreader service: %w", err)
	}

	return &cfg, nil
}

// JsonrpcConfig holds configuration values for the jsonrpc service.
type JsonrpcConfig struct {

	// Postgres endpoint in the 'postgres://user:password@hostname:port/database' format (URL).
	//
	// If not set, or set to empty string, will defer the behaviour to the PG driver.
	// See [this](https://www.postgresql.org/docs/current/libpq-envars.html) for more information.
	//
	// It is also possible to set the endpoint without a password and load it from Postgres' passfile.
	// See [this](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-PASSFILE)
	// for more information.
	DatabaseConnection URL `mapstructure:"CARTESI_DATABASE_CONNECTION"`

	// HTTP address for the jsonrpc api.
	JsonrpcApiAddress string `mapstructure:"CARTESI_JSONRPC_API_ADDRESS"`

	// HTTP address for telemetry service.
	TelemetryAddress string `mapstructure:"CARTESI_TELEMETRY_ADDRESS"`

	// If set to true, the node will add colors to its log output.
	LogColor bool `mapstructure:"CARTESI_LOG_COLOR"`

	// One of "debug", "info", "warn", "error".
	LogLevel LogLevel `mapstructure:"CARTESI_LOG_LEVEL"`

	// How many seconds the node expects services take initializing before aborting.
	MaxStartupTime Duration `mapstructure:"CARTESI_MAX_STARTUP_TIME"`
}

// LoadJsonrpcConfig reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func LoadJsonrpcConfig() (*JsonrpcConfig, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg JsonrpcConfig
	var err error

	cfg.DatabaseConnection, err = GetDatabaseConnection()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_DATABASE_CONNECTION: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_DATABASE_CONNECTION is required for the jsonrpc service: %w", err)
	}

	cfg.JsonrpcApiAddress, err = GetJsonrpcApiAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_JSONRPC_API_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_JSONRPC_API_ADDRESS is required for the jsonrpc service: %w", err)
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_TELEMETRY_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_TELEMETRY_ADDRESS is required for the jsonrpc service: %w", err)
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_COLOR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_COLOR is required for the jsonrpc service: %w", err)
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_LEVEL is required for the jsonrpc service: %w", err)
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_MAX_STARTUP_TIME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_MAX_STARTUP_TIME is required for the jsonrpc service: %w", err)
	}

	return &cfg, nil
}

// NodeConfig holds configuration values for the node service.
type NodeConfig struct {

	// The default block to be used by EVM Reader and Claimer when requesting new blocks.
	// One of 'latest', 'pending', 'safe', 'finalized'
	BlockchainDefaultBlock DefaultBlock `mapstructure:"CARTESI_BLOCKCHAIN_DEFAULT_BLOCK"`

	// HTTP endpoint for the blockchain RPC provider.
	BlockchainHttpEndpoint URL `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_ENDPOINT"`

	// An unique identifier representing a blockchain network.
	BlockchainId uint64 `mapstructure:"CARTESI_BLOCKCHAIN_ID"`

	// If set to true the node will send transactions using the legacy gas fee model
	// (instead of EIP-1559).
	BlockchainLegacyEnabled bool `mapstructure:"CARTESI_BLOCKCHAIN_LEGACY_ENABLED"`

	// Block subscription timeout in seconds.
	BlockchainSubscriptionTimeout uint64 `mapstructure:"CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT"`

	// WebSocket endpoint for the blockchain RPC provider.
	BlockchainWsEndpoint URL `mapstructure:"CARTESI_BLOCKCHAIN_WS_ENDPOINT"`

	// Postgres endpoint in the 'postgres://user:password@hostname:port/database' format (URL).
	//
	// If not set, or set to empty string, will defer the behaviour to the PG driver.
	// See [this](https://www.postgresql.org/docs/current/libpq-envars.html) for more information.
	//
	// It is also possible to set the endpoint without a password and load it from Postgres' passfile.
	// See [this](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-PASSFILE)
	// for more information.
	DatabaseConnection URL `mapstructure:"CARTESI_DATABASE_CONNECTION"`

	// If set to false, the node will not submit claims (reader mode).
	FeatureClaimSubmissionEnabled bool `mapstructure:"CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED"`

	// If set to false, the node will not read inputs from the blockchain.
	FeatureInputReaderEnabled bool `mapstructure:"CARTESI_FEATURE_INPUT_READER_ENABLED"`

	// If set to false, the node will not start the inspect service.
	FeatureInspectEnabled bool `mapstructure:"CARTESI_FEATURE_INSPECT_ENABLED"`

	// If set to false, the node will not start the jsonrpc api service.
	FeatureJsonrpcApiEnabled bool `mapstructure:"CARTESI_FEATURE_JSONRPC_API_ENABLED"`

	// If set to false, the node will *not* check whether the Cartesi machine hash from
	// the snapshot matches the hash in the Application contract.
	FeatureMachineHashCheckEnabled bool `mapstructure:"CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED"`

	// HTTP address for inspect.
	InspectAddress string `mapstructure:"CARTESI_INSPECT_ADDRESS"`

	// HTTP address for the jsonrpc api.
	JsonrpcApiAddress string `mapstructure:"CARTESI_JSONRPC_API_ADDRESS"`

	// HTTP address for telemetry service.
	TelemetryAddress string `mapstructure:"CARTESI_TELEMETRY_ADDRESS"`

	// If set to true, the node will add colors to its log output.
	LogColor bool `mapstructure:"CARTESI_LOG_COLOR"`

	// One of "debug", "info", "warn", "error".
	LogLevel LogLevel `mapstructure:"CARTESI_LOG_LEVEL"`

	// Remote Cartesi Machine server log level.
	// One of "trace", "debug", "info", "warning", "error", "fatal".
	RemoteMachineLogLevel MachineLogLevel `mapstructure:"CARTESI_REMOTE_MACHINE_LOG_LEVEL"`

	// How many seconds the node will wait before querying the database for new inputs.
	AdvancerPollingInterval Duration `mapstructure:"CARTESI_ADVANCER_POLLING_INTERVAL"`

	// Maximum number of retry attempts for HTTP blockchain requests after encountering an error.
	BlockchainHttpMaxRetries uint64 `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES"`

	// Maximum wait time in seconds for the exponential backoff retry policy. The delay between retries for HTTP blockchain requests will never exceed this value, regardless of the backoff calculation.
	BlockchainHttpRetryMaxWait Duration `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT"`

	// Minimum wait time in seconds for the exponential backoff retry policy. This is the initial delay before the first retry for HTTP blockchain requests.
	BlockchainHttpRetryMinWait Duration `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT"`

	// How many seconds the node will wait before querying the database for new claims.
	ClaimerPollingInterval Duration `mapstructure:"CARTESI_CLAIMER_POLLING_INTERVAL"`

	// How many seconds the node expects services take initializing before aborting.
	MaxStartupTime Duration `mapstructure:"CARTESI_MAX_STARTUP_TIME"`

	// How many seconds the node will wait before trying to finish epochs for all applications.
	ValidatorPollingInterval Duration `mapstructure:"CARTESI_VALIDATOR_POLLING_INTERVAL"`

	// Path to the directory where the snapshots will be written.
	SnapshotDir string `mapstructure:"CARTESI_SNAPSHOT_DIR"`
}

// LoadNodeConfig reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func LoadNodeConfig() (*NodeConfig, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg NodeConfig
	var err error

	cfg.BlockchainDefaultBlock, err = GetBlockchainDefaultBlock()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_DEFAULT_BLOCK: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_DEFAULT_BLOCK is required for the node service: %w", err)
	}

	cfg.BlockchainHttpEndpoint, err = GetBlockchainHttpEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_ENDPOINT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_ENDPOINT is required for the node service: %w", err)
	}

	cfg.BlockchainId, err = GetBlockchainId()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_ID: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_ID is required for the node service: %w", err)
	}

	cfg.BlockchainLegacyEnabled, err = GetBlockchainLegacyEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_LEGACY_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_LEGACY_ENABLED is required for the node service: %w", err)
	}

	cfg.BlockchainSubscriptionTimeout, err = GetBlockchainSubscriptionTimeout()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT is required for the node service: %w", err)
	}

	cfg.BlockchainWsEndpoint, err = GetBlockchainWsEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_WS_ENDPOINT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_WS_ENDPOINT is required for the node service: %w", err)
	}

	cfg.DatabaseConnection, err = GetDatabaseConnection()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_DATABASE_CONNECTION: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_DATABASE_CONNECTION is required for the node service: %w", err)
	}

	cfg.FeatureClaimSubmissionEnabled, err = GetFeatureClaimSubmissionEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED is required for the node service: %w", err)
	}

	cfg.FeatureInputReaderEnabled, err = GetFeatureInputReaderEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_INPUT_READER_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_INPUT_READER_ENABLED is required for the node service: %w", err)
	}

	cfg.FeatureInspectEnabled, err = GetFeatureInspectEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_INSPECT_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_INSPECT_ENABLED is required for the node service: %w", err)
	}

	cfg.FeatureJsonrpcApiEnabled, err = GetFeatureJsonrpcApiEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_JSONRPC_API_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_JSONRPC_API_ENABLED is required for the node service: %w", err)
	}

	cfg.FeatureMachineHashCheckEnabled, err = GetFeatureMachineHashCheckEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED is required for the node service: %w", err)
	}

	cfg.InspectAddress, err = GetInspectAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_INSPECT_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_INSPECT_ADDRESS is required for the node service: %w", err)
	}

	cfg.JsonrpcApiAddress, err = GetJsonrpcApiAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_JSONRPC_API_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_JSONRPC_API_ADDRESS is required for the node service: %w", err)
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_TELEMETRY_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_TELEMETRY_ADDRESS is required for the node service: %w", err)
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_COLOR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_COLOR is required for the node service: %w", err)
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_LEVEL is required for the node service: %w", err)
	}

	cfg.RemoteMachineLogLevel, err = GetRemoteMachineLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_REMOTE_MACHINE_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_REMOTE_MACHINE_LOG_LEVEL is required for the node service: %w", err)
	}

	cfg.AdvancerPollingInterval, err = GetAdvancerPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_ADVANCER_POLLING_INTERVAL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_ADVANCER_POLLING_INTERVAL is required for the node service: %w", err)
	}

	cfg.BlockchainHttpMaxRetries, err = GetBlockchainHttpMaxRetries()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES is required for the node service: %w", err)
	}

	cfg.BlockchainHttpRetryMaxWait, err = GetBlockchainHttpRetryMaxWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT is required for the node service: %w", err)
	}

	cfg.BlockchainHttpRetryMinWait, err = GetBlockchainHttpRetryMinWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT is required for the node service: %w", err)
	}

	cfg.ClaimerPollingInterval, err = GetClaimerPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_CLAIMER_POLLING_INTERVAL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_CLAIMER_POLLING_INTERVAL is required for the node service: %w", err)
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_MAX_STARTUP_TIME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_MAX_STARTUP_TIME is required for the node service: %w", err)
	}

	cfg.ValidatorPollingInterval, err = GetValidatorPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_VALIDATOR_POLLING_INTERVAL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_VALIDATOR_POLLING_INTERVAL is required for the node service: %w", err)
	}

	cfg.SnapshotDir, err = GetSnapshotDir()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_SNAPSHOT_DIR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_SNAPSHOT_DIR is required for the node service: %w", err)
	}

	return &cfg, nil
}

// ValidatorConfig holds configuration values for the validator service.
type ValidatorConfig struct {

	// Postgres endpoint in the 'postgres://user:password@hostname:port/database' format (URL).
	//
	// If not set, or set to empty string, will defer the behaviour to the PG driver.
	// See [this](https://www.postgresql.org/docs/current/libpq-envars.html) for more information.
	//
	// It is also possible to set the endpoint without a password and load it from Postgres' passfile.
	// See [this](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-PASSFILE)
	// for more information.
	DatabaseConnection URL `mapstructure:"CARTESI_DATABASE_CONNECTION"`

	// HTTP address for telemetry service.
	TelemetryAddress string `mapstructure:"CARTESI_TELEMETRY_ADDRESS"`

	// If set to true, the node will add colors to its log output.
	LogColor bool `mapstructure:"CARTESI_LOG_COLOR"`

	// One of "debug", "info", "warn", "error".
	LogLevel LogLevel `mapstructure:"CARTESI_LOG_LEVEL"`

	// How many seconds the node expects services take initializing before aborting.
	MaxStartupTime Duration `mapstructure:"CARTESI_MAX_STARTUP_TIME"`

	// How many seconds the node will wait before trying to finish epochs for all applications.
	ValidatorPollingInterval Duration `mapstructure:"CARTESI_VALIDATOR_POLLING_INTERVAL"`
}

// LoadValidatorConfig reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func LoadValidatorConfig() (*ValidatorConfig, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg ValidatorConfig
	var err error

	cfg.DatabaseConnection, err = GetDatabaseConnection()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_DATABASE_CONNECTION: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_DATABASE_CONNECTION is required for the validator service: %w", err)
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_TELEMETRY_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_TELEMETRY_ADDRESS is required for the validator service: %w", err)
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_COLOR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_COLOR is required for the validator service: %w", err)
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_LOG_LEVEL is required for the validator service: %w", err)
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_MAX_STARTUP_TIME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_MAX_STARTUP_TIME is required for the validator service: %w", err)
	}

	cfg.ValidatorPollingInterval, err = GetValidatorPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get CARTESI_VALIDATOR_POLLING_INTERVAL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("CARTESI_VALIDATOR_POLLING_INTERVAL is required for the validator service: %w", err)
	}

	return &cfg, nil
}

// ToAdvancerConfig converts a NodeConfig to a AdvancerConfig.
func (c *NodeConfig) ToAdvancerConfig() *AdvancerConfig {
	return &AdvancerConfig{
		DatabaseConnection:             c.DatabaseConnection,
		FeatureInspectEnabled:          c.FeatureInspectEnabled,
		FeatureMachineHashCheckEnabled: c.FeatureMachineHashCheckEnabled,
		InspectAddress:                 c.InspectAddress,
		TelemetryAddress:               c.TelemetryAddress,
		LogColor:                       c.LogColor,
		LogLevel:                       c.LogLevel,
		RemoteMachineLogLevel:          c.RemoteMachineLogLevel,
		AdvancerPollingInterval:        c.AdvancerPollingInterval,
		MaxStartupTime:                 c.MaxStartupTime,
		SnapshotDir:                    c.SnapshotDir,
	}
}

// ToClaimerConfig converts a NodeConfig to a ClaimerConfig.
func (c *NodeConfig) ToClaimerConfig() *ClaimerConfig {
	return &ClaimerConfig{
		BlockchainDefaultBlock:        c.BlockchainDefaultBlock,
		BlockchainHttpEndpoint:        c.BlockchainHttpEndpoint,
		BlockchainId:                  c.BlockchainId,
		BlockchainLegacyEnabled:       c.BlockchainLegacyEnabled,
		DatabaseConnection:            c.DatabaseConnection,
		FeatureClaimSubmissionEnabled: c.FeatureClaimSubmissionEnabled,
		TelemetryAddress:              c.TelemetryAddress,
		LogColor:                      c.LogColor,
		LogLevel:                      c.LogLevel,
		BlockchainHttpMaxRetries:      c.BlockchainHttpMaxRetries,
		BlockchainHttpRetryMaxWait:    c.BlockchainHttpRetryMaxWait,
		BlockchainHttpRetryMinWait:    c.BlockchainHttpRetryMinWait,
		ClaimerPollingInterval:        c.ClaimerPollingInterval,
		MaxStartupTime:                c.MaxStartupTime,
	}
}

// ToEvmreaderConfig converts a NodeConfig to a EvmreaderConfig.
func (c *NodeConfig) ToEvmreaderConfig() *EvmreaderConfig {
	return &EvmreaderConfig{
		BlockchainDefaultBlock:        c.BlockchainDefaultBlock,
		BlockchainHttpEndpoint:        c.BlockchainHttpEndpoint,
		BlockchainId:                  c.BlockchainId,
		BlockchainSubscriptionTimeout: c.BlockchainSubscriptionTimeout,
		BlockchainWsEndpoint:          c.BlockchainWsEndpoint,
		DatabaseConnection:            c.DatabaseConnection,
		FeatureInputReaderEnabled:     c.FeatureInputReaderEnabled,
		TelemetryAddress:              c.TelemetryAddress,
		LogColor:                      c.LogColor,
		LogLevel:                      c.LogLevel,
		BlockchainHttpMaxRetries:      c.BlockchainHttpMaxRetries,
		BlockchainHttpRetryMaxWait:    c.BlockchainHttpRetryMaxWait,
		BlockchainHttpRetryMinWait:    c.BlockchainHttpRetryMinWait,
		MaxStartupTime:                c.MaxStartupTime,
	}
}

// ToJsonrpcConfig converts a NodeConfig to a JsonrpcConfig.
func (c *NodeConfig) ToJsonrpcConfig() *JsonrpcConfig {
	return &JsonrpcConfig{
		DatabaseConnection: c.DatabaseConnection,
		JsonrpcApiAddress:  c.JsonrpcApiAddress,
		TelemetryAddress:   c.TelemetryAddress,
		LogColor:           c.LogColor,
		LogLevel:           c.LogLevel,
		MaxStartupTime:     c.MaxStartupTime,
	}
}

// ToValidatorConfig converts a NodeConfig to a ValidatorConfig.
func (c *NodeConfig) ToValidatorConfig() *ValidatorConfig {
	return &ValidatorConfig{
		DatabaseConnection:       c.DatabaseConnection,
		TelemetryAddress:         c.TelemetryAddress,
		LogColor:                 c.LogColor,
		LogLevel:                 c.LogLevel,
		MaxStartupTime:           c.MaxStartupTime,
		ValidatorPollingInterval: c.ValidatorPollingInterval,
	}
}

// GetAuthAwsKmsKeyId returns the value for the environment variable CARTESI_AUTH_AWS_KMS_KEY_ID.
func GetAuthAwsKmsKeyId() (RedactedString, error) {
	s := viper.GetString(AUTH_AWS_KMS_KEY_ID)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_AWS_KMS_KEY_ID, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", AUTH_AWS_KMS_KEY_ID, ErrNotDefined)
}

// GetAuthAwsKmsRegion returns the value for the environment variable CARTESI_AUTH_AWS_KMS_REGION.
func GetAuthAwsKmsRegion() (RedactedString, error) {
	s := viper.GetString(AUTH_AWS_KMS_REGION)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_AWS_KMS_REGION, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", AUTH_AWS_KMS_REGION, ErrNotDefined)
}

// GetAuthKind returns the value for the environment variable CARTESI_AUTH_KIND.
func GetAuthKind() (AuthKind, error) {
	s := viper.GetString(AUTH_KIND)
	if s != "" {
		v, err := toAuthKind(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_KIND, err)
		}
		return v, nil
	}
	return notDefinedAuthKind(), fmt.Errorf("%s: %w", AUTH_KIND, ErrNotDefined)
}

// GetAuthMnemonic returns the value for the environment variable CARTESI_AUTH_MNEMONIC.
func GetAuthMnemonic() (RedactedString, error) {
	s := viper.GetString(AUTH_MNEMONIC)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", AUTH_MNEMONIC, ErrNotDefined)
}

// GetAuthMnemonicAccountIndex returns the value for the environment variable CARTESI_AUTH_MNEMONIC_ACCOUNT_INDEX.
func GetAuthMnemonicAccountIndex() (RedactedUint, error) {
	s := viper.GetString(AUTH_MNEMONIC_ACCOUNT_INDEX)
	if s != "" {
		v, err := toRedactedUint(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC_ACCOUNT_INDEX, err)
		}
		return v, nil
	}
	return notDefinedRedactedUint(), fmt.Errorf("%s: %w", AUTH_MNEMONIC_ACCOUNT_INDEX, ErrNotDefined)
}

// GetAuthMnemonicFile returns the value for the environment variable CARTESI_AUTH_MNEMONIC_FILE.
func GetAuthMnemonicFile() (string, error) {
	s := viper.GetString(AUTH_MNEMONIC_FILE)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC_FILE, err)
		}
		return v, nil
	}
	return notDefinedstring(), fmt.Errorf("%s: %w", AUTH_MNEMONIC_FILE, ErrNotDefined)
}

// GetAuthPrivateKey returns the value for the environment variable CARTESI_AUTH_PRIVATE_KEY.
func GetAuthPrivateKey() (RedactedString, error) {
	s := viper.GetString(AUTH_PRIVATE_KEY)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_PRIVATE_KEY, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", AUTH_PRIVATE_KEY, ErrNotDefined)
}

// GetAuthPrivateKeyFile returns the value for the environment variable CARTESI_AUTH_PRIVATE_KEY_FILE.
func GetAuthPrivateKeyFile() (string, error) {
	s := viper.GetString(AUTH_PRIVATE_KEY_FILE)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_PRIVATE_KEY_FILE, err)
		}
		return v, nil
	}
	return notDefinedstring(), fmt.Errorf("%s: %w", AUTH_PRIVATE_KEY_FILE, ErrNotDefined)
}

// GetBlockchainDefaultBlock returns the value for the environment variable CARTESI_BLOCKCHAIN_DEFAULT_BLOCK.
func GetBlockchainDefaultBlock() (DefaultBlock, error) {
	s := viper.GetString(BLOCKCHAIN_DEFAULT_BLOCK)
	if s != "" {
		v, err := toDefaultBlock(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_DEFAULT_BLOCK, err)
		}
		return v, nil
	}
	return notDefinedDefaultBlock(), fmt.Errorf("%s: %w", BLOCKCHAIN_DEFAULT_BLOCK, ErrNotDefined)
}

// GetBlockchainHttpEndpoint returns the value for the environment variable CARTESI_BLOCKCHAIN_HTTP_ENDPOINT.
func GetBlockchainHttpEndpoint() (URL, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_ENDPOINT)
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_ENDPOINT, err)
		}
		return v, nil
	}
	return notDefinedURL(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_ENDPOINT, ErrNotDefined)
}

// GetBlockchainId returns the value for the environment variable CARTESI_BLOCKCHAIN_ID.
func GetBlockchainId() (uint64, error) {
	s := viper.GetString(BLOCKCHAIN_ID)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_ID, err)
		}
		return v, nil
	}
	return notDefineduint64(), fmt.Errorf("%s: %w", BLOCKCHAIN_ID, ErrNotDefined)
}

// GetBlockchainLegacyEnabled returns the value for the environment variable CARTESI_BLOCKCHAIN_LEGACY_ENABLED.
func GetBlockchainLegacyEnabled() (bool, error) {
	s := viper.GetString(BLOCKCHAIN_LEGACY_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_LEGACY_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), fmt.Errorf("%s: %w", BLOCKCHAIN_LEGACY_ENABLED, ErrNotDefined)
}

// GetBlockchainSubscriptionTimeout returns the value for the environment variable CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT.
func GetBlockchainSubscriptionTimeout() (uint64, error) {
	s := viper.GetString(BLOCKCHAIN_SUBSCRIPTION_TIMEOUT)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_SUBSCRIPTION_TIMEOUT, err)
		}
		return v, nil
	}
	return notDefineduint64(), fmt.Errorf("%s: %w", BLOCKCHAIN_SUBSCRIPTION_TIMEOUT, ErrNotDefined)
}

// GetBlockchainWsEndpoint returns the value for the environment variable CARTESI_BLOCKCHAIN_WS_ENDPOINT.
func GetBlockchainWsEndpoint() (URL, error) {
	s := viper.GetString(BLOCKCHAIN_WS_ENDPOINT)
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_WS_ENDPOINT, err)
		}
		return v, nil
	}
	return notDefinedURL(), fmt.Errorf("%s: %w", BLOCKCHAIN_WS_ENDPOINT, ErrNotDefined)
}

// GetContractsApplicationFactoryAddress returns the value for the environment variable CARTESI_CONTRACTS_APPLICATION_FACTORY_ADDRESS.
func GetContractsApplicationFactoryAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_APPLICATION_FACTORY_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_APPLICATION_FACTORY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), fmt.Errorf("%s: %w", CONTRACTS_APPLICATION_FACTORY_ADDRESS, ErrNotDefined)
}

// GetContractsAuthorityFactoryAddress returns the value for the environment variable CARTESI_CONTRACTS_AUTHORITY_FACTORY_ADDRESS.
func GetContractsAuthorityFactoryAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_AUTHORITY_FACTORY_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_AUTHORITY_FACTORY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), fmt.Errorf("%s: %w", CONTRACTS_AUTHORITY_FACTORY_ADDRESS, ErrNotDefined)
}

// GetContractsInputBoxAddress returns the value for the environment variable CARTESI_CONTRACTS_INPUT_BOX_ADDRESS.
func GetContractsInputBoxAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_INPUT_BOX_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_INPUT_BOX_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), fmt.Errorf("%s: %w", CONTRACTS_INPUT_BOX_ADDRESS, ErrNotDefined)
}

// GetContractsSelfHostedApplicationFactoryAddress returns the value for the environment variable CARTESI_CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS.
func GetContractsSelfHostedApplicationFactoryAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), fmt.Errorf("%s: %w", CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS, ErrNotDefined)
}

// GetDatabaseConnection returns the value for the environment variable CARTESI_DATABASE_CONNECTION.
func GetDatabaseConnection() (URL, error) {
	s := viper.GetString(DATABASE_CONNECTION)
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", DATABASE_CONNECTION, err)
		}
		return v, nil
	}
	return notDefinedURL(), fmt.Errorf("%s: %w", DATABASE_CONNECTION, ErrNotDefined)
}

// GetFeatureClaimSubmissionEnabled returns the value for the environment variable CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED.
func GetFeatureClaimSubmissionEnabled() (bool, error) {
	s := viper.GetString(FEATURE_CLAIM_SUBMISSION_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_CLAIM_SUBMISSION_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), fmt.Errorf("%s: %w", FEATURE_CLAIM_SUBMISSION_ENABLED, ErrNotDefined)
}

// GetFeatureInputReaderEnabled returns the value for the environment variable CARTESI_FEATURE_INPUT_READER_ENABLED.
func GetFeatureInputReaderEnabled() (bool, error) {
	s := viper.GetString(FEATURE_INPUT_READER_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_INPUT_READER_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), fmt.Errorf("%s: %w", FEATURE_INPUT_READER_ENABLED, ErrNotDefined)
}

// GetFeatureInspectEnabled returns the value for the environment variable CARTESI_FEATURE_INSPECT_ENABLED.
func GetFeatureInspectEnabled() (bool, error) {
	s := viper.GetString(FEATURE_INSPECT_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_INSPECT_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), fmt.Errorf("%s: %w", FEATURE_INSPECT_ENABLED, ErrNotDefined)
}

// GetFeatureJsonrpcApiEnabled returns the value for the environment variable CARTESI_FEATURE_JSONRPC_API_ENABLED.
func GetFeatureJsonrpcApiEnabled() (bool, error) {
	s := viper.GetString(FEATURE_JSONRPC_API_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_JSONRPC_API_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), fmt.Errorf("%s: %w", FEATURE_JSONRPC_API_ENABLED, ErrNotDefined)
}

// GetFeatureMachineHashCheckEnabled returns the value for the environment variable CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED.
func GetFeatureMachineHashCheckEnabled() (bool, error) {
	s := viper.GetString(FEATURE_MACHINE_HASH_CHECK_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_MACHINE_HASH_CHECK_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), fmt.Errorf("%s: %w", FEATURE_MACHINE_HASH_CHECK_ENABLED, ErrNotDefined)
}

// GetInspectAddress returns the value for the environment variable CARTESI_INSPECT_ADDRESS.
func GetInspectAddress() (string, error) {
	s := viper.GetString(INSPECT_ADDRESS)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", INSPECT_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedstring(), fmt.Errorf("%s: %w", INSPECT_ADDRESS, ErrNotDefined)
}

// GetJsonrpcApiAddress returns the value for the environment variable CARTESI_JSONRPC_API_ADDRESS.
func GetJsonrpcApiAddress() (string, error) {
	s := viper.GetString(JSONRPC_API_ADDRESS)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", JSONRPC_API_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedstring(), fmt.Errorf("%s: %w", JSONRPC_API_ADDRESS, ErrNotDefined)
}

// GetTelemetryAddress returns the value for the environment variable CARTESI_TELEMETRY_ADDRESS.
func GetTelemetryAddress() (string, error) {
	s := viper.GetString(TELEMETRY_ADDRESS)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", TELEMETRY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedstring(), fmt.Errorf("%s: %w", TELEMETRY_ADDRESS, ErrNotDefined)
}

// GetLogColor returns the value for the environment variable CARTESI_LOG_COLOR.
func GetLogColor() (bool, error) {
	s := viper.GetString(LOG_COLOR)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", LOG_COLOR, err)
		}
		return v, nil
	}
	return notDefinedbool(), fmt.Errorf("%s: %w", LOG_COLOR, ErrNotDefined)
}

// GetLogLevel returns the value for the environment variable CARTESI_LOG_LEVEL.
func GetLogLevel() (LogLevel, error) {
	s := viper.GetString(LOG_LEVEL)
	if s != "" {
		v, err := toLogLevel(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", LOG_LEVEL, err)
		}
		return v, nil
	}
	return notDefinedLogLevel(), fmt.Errorf("%s: %w", LOG_LEVEL, ErrNotDefined)
}

// GetRemoteMachineLogLevel returns the value for the environment variable CARTESI_REMOTE_MACHINE_LOG_LEVEL.
func GetRemoteMachineLogLevel() (MachineLogLevel, error) {
	s := viper.GetString(REMOTE_MACHINE_LOG_LEVEL)
	if s != "" {
		v, err := toMachineLogLevel(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", REMOTE_MACHINE_LOG_LEVEL, err)
		}
		return v, nil
	}
	return notDefinedMachineLogLevel(), fmt.Errorf("%s: %w", REMOTE_MACHINE_LOG_LEVEL, ErrNotDefined)
}

// GetAdvancerPollingInterval returns the value for the environment variable CARTESI_ADVANCER_POLLING_INTERVAL.
func GetAdvancerPollingInterval() (Duration, error) {
	s := viper.GetString(ADVANCER_POLLING_INTERVAL)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", ADVANCER_POLLING_INTERVAL, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", ADVANCER_POLLING_INTERVAL, ErrNotDefined)
}

// GetBlockchainHttpMaxRetries returns the value for the environment variable CARTESI_BLOCKCHAIN_HTTP_MAX_RETRIES.
func GetBlockchainHttpMaxRetries() (uint64, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_MAX_RETRIES)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_MAX_RETRIES, err)
		}
		return v, nil
	}
	return notDefineduint64(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_MAX_RETRIES, ErrNotDefined)
}

// GetBlockchainHttpRetryMaxWait returns the value for the environment variable CARTESI_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT.
func GetBlockchainHttpRetryMaxWait() (Duration, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_RETRY_MAX_WAIT)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_RETRY_MAX_WAIT, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_RETRY_MAX_WAIT, ErrNotDefined)
}

// GetBlockchainHttpRetryMinWait returns the value for the environment variable CARTESI_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT.
func GetBlockchainHttpRetryMinWait() (Duration, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_RETRY_MIN_WAIT)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_RETRY_MIN_WAIT, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_RETRY_MIN_WAIT, ErrNotDefined)
}

// GetClaimerPollingInterval returns the value for the environment variable CARTESI_CLAIMER_POLLING_INTERVAL.
func GetClaimerPollingInterval() (Duration, error) {
	s := viper.GetString(CLAIMER_POLLING_INTERVAL)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CLAIMER_POLLING_INTERVAL, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", CLAIMER_POLLING_INTERVAL, ErrNotDefined)
}

// GetMaxStartupTime returns the value for the environment variable CARTESI_MAX_STARTUP_TIME.
func GetMaxStartupTime() (Duration, error) {
	s := viper.GetString(MAX_STARTUP_TIME)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", MAX_STARTUP_TIME, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", MAX_STARTUP_TIME, ErrNotDefined)
}

// GetValidatorPollingInterval returns the value for the environment variable CARTESI_VALIDATOR_POLLING_INTERVAL.
func GetValidatorPollingInterval() (Duration, error) {
	s := viper.GetString(VALIDATOR_POLLING_INTERVAL)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", VALIDATOR_POLLING_INTERVAL, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", VALIDATOR_POLLING_INTERVAL, ErrNotDefined)
}

// GetSnapshotDir returns the value for the environment variable CARTESI_SNAPSHOT_DIR.
func GetSnapshotDir() (string, error) {
	s := viper.GetString(SNAPSHOT_DIR)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", SNAPSHOT_DIR, err)
		}
		return v, nil
	}
	return notDefinedstring(), fmt.Errorf("%s: %w", SNAPSHOT_DIR, ErrNotDefined)
}

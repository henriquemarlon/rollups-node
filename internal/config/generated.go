// Code generated by internal/config/generate.
// DO NOT EDIT.
//
// (c) Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: Apache-2.0 (see LICENSE)

package config

import (
	"fmt"

	"github.com/spf13/viper"
)

var ErrNotDefined = fmt.Errorf("variable not defined")

func init() {
	// Automatically bind environment variables.
	viper.AutomaticEnv()
}

const (
	AUTH_AWS_KMS_KEY_ID                               = "CARTESI_AUTH_AWS_KMS_KEY_ID"
	AUTH_AWS_KMS_REGION                               = "CARTESI_AUTH_AWS_KMS_REGION"
	AUTH_KIND                                         = "CARTESI_AUTH_KIND"
	AUTH_MNEMONIC                                     = "CARTESI_AUTH_MNEMONIC"
	AUTH_MNEMONIC_ACCOUNT_INDEX                       = "CARTESI_AUTH_MNEMONIC_ACCOUNT_INDEX"
	AUTH_MNEMONIC_FILE                                = "CARTESI_AUTH_MNEMONIC_FILE"
	AUTH_PRIVATE_KEY                                  = "CARTESI_AUTH_PRIVATE_KEY"
	AUTH_PRIVATE_KEY_FILE                             = "CARTESI_AUTH_PRIVATE_KEY_FILE"
	BLOCKCHAIN_DEFAULT_BLOCK                          = "CARTESI_BLOCKCHAIN_DEFAULT_BLOCK"
	BLOCKCHAIN_HTTP_ENDPOINT                          = "CARTESI_BLOCKCHAIN_HTTP_ENDPOINT"
	BLOCKCHAIN_ID                                     = "CARTESI_BLOCKCHAIN_ID"
	BLOCKCHAIN_LEGACY_ENABLED                         = "CARTESI_BLOCKCHAIN_LEGACY_ENABLED"
	BLOCKCHAIN_SUBSCRIPTION_TIMEOUT                   = "CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT"
	BLOCKCHAIN_WS_ENDPOINT                            = "CARTESI_BLOCKCHAIN_WS_ENDPOINT"
	CONTRACTS_APPLICATION_FACTORY_ADDRESS             = "CARTESI_CONTRACTS_APPLICATION_FACTORY_ADDRESS"
	CONTRACTS_AUTHORITY_FACTORY_ADDRESS               = "CARTESI_CONTRACTS_AUTHORITY_FACTORY_ADDRESS"
	CONTRACTS_INPUT_BOX_ADDRESS                       = "CARTESI_CONTRACTS_INPUT_BOX_ADDRESS"
	CONTRACTS_INPUT_BOX_DEPLOYMENT_BLOCK_NUMBER       = "CARTESI_CONTRACTS_INPUT_BOX_DEPLOYMENT_BLOCK_NUMBER"
	CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS = "CARTESI_CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS"
	DATABASE_CONNECTION                               = "CARTESI_DATABASE_CONNECTION"
	FEATURE_CLAIM_SUBMISSION_ENABLED                  = "CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED"
	FEATURE_INPUT_READER_ENABLED                      = "CARTESI_FEATURE_INPUT_READER_ENABLED"
	FEATURE_INSPECT_ENABLED                           = "CARTESI_FEATURE_INSPECT_ENABLED"
	FEATURE_MACHINE_HASH_CHECK_ENABLED                = "CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED"
	INSPECT_ADDRESS                                   = "CARTESI_INSPECT_ADDRESS"
	TELEMETRY_ADDRESS                                 = "CARTESI_TELEMETRY_ADDRESS"
	LOG_COLOR                                         = "CARTESI_LOG_COLOR"
	LOG_LEVEL                                         = "CARTESI_LOG_LEVEL"
	REMOTE_MACHINE_LOG_LEVEL                          = "CARTESI_REMOTE_MACHINE_LOG_LEVEL"
	ADVANCER_POLLING_INTERVAL                         = "CARTESI_ADVANCER_POLLING_INTERVAL"
	CLAIMER_POLLING_INTERVAL                          = "CARTESI_CLAIMER_POLLING_INTERVAL"
	EVM_READER_RETRY_POLICY_MAX_DELAY                 = "CARTESI_EVM_READER_RETRY_POLICY_MAX_DELAY"
	EVM_READER_RETRY_POLICY_MAX_RETRIES               = "CARTESI_EVM_READER_RETRY_POLICY_MAX_RETRIES"
	MAX_STARTUP_TIME                                  = "CARTESI_MAX_STARTUP_TIME"
	VALIDATOR_POLLING_INTERVAL                        = "CARTESI_VALIDATOR_POLLING_INTERVAL"
	SNAPSHOT_DIR                                      = "CARTESI_SNAPSHOT_DIR"
)

// Config holds all configuration values.
type Config struct {

	// The default block to be used by EVM Reader and Claimer when requesting new blocks.
	// One of 'latest', 'pending', 'safe', 'finalized'
	BlockchainDefaultBlock DefaultBlock `mapstructure:"CARTESI_BLOCKCHAIN_DEFAULT_BLOCK"`

	// HTTP endpoint for the blockchain RPC provider. [Required: evm-reader and claimer]
	BlockchainHttpEndpoint URL `mapstructure:"CARTESI_BLOCKCHAIN_HTTP_ENDPOINT"`

	// An unique identifier representing a blockchain network. [Required: evm-reader and claimer]
	BlockchainId uint64 `mapstructure:"CARTESI_BLOCKCHAIN_ID"`

	// If set to true the node will send transactions using the legacy gas fee model
	// (instead of EIP-1559).
	BlockchainLegacyEnabled bool `mapstructure:"CARTESI_BLOCKCHAIN_LEGACY_ENABLED"`

	// Block subscription timeout in seconds.
	BlockchainSubscriptionTimeout uint64 `mapstructure:"CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT"`

	// WebSocket endpoint for the blockchain RPC provider. [Required: evm-reader]
	BlockchainWsEndpoint URL `mapstructure:"CARTESI_BLOCKCHAIN_WS_ENDPOINT"`

	// Address of the InputBox contract. [Required: evm-reader]
	ContractsInputBoxAddress Address `mapstructure:"CARTESI_CONTRACTS_INPUT_BOX_ADDRESS"`

	// The InputBox contract deployment block number.
	// The node will begin to read blockchain events from this block. [Required: evm-reader]
	ContractsInputBoxDeploymentBlockNumber uint64 `mapstructure:"CARTESI_CONTRACTS_INPUT_BOX_DEPLOYMENT_BLOCK_NUMBER"`

	// Postgres endpoint in the 'postgres://user:password@hostname:port/database' format (URL).
	//
	// If not set, or set to empty string, will defer the behaviour to the PG driver.
	// See [this](https://www.postgresql.org/docs/current/libpq-envars.html) for more information.
	//
	// It is also possible to set the endpoint without a password and load it from Postgres' passfile.
	// See [this](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-PASSFILE)
	// for more information. [Required: all]
	DatabaseConnection URL `mapstructure:"CARTESI_DATABASE_CONNECTION"`

	// If set to false, the node will not submit claims (reader mode).
	FeatureClaimSubmissionEnabled bool `mapstructure:"CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED"`

	// If set to false, the node will not read inputs from the blockchain.
	FeatureInputReaderEnabled bool `mapstructure:"CARTESI_FEATURE_INPUT_READER_ENABLED"`

	// If set to false, the node will not start the inspect service.
	FeatureInspectEnabled bool `mapstructure:"CARTESI_FEATURE_INSPECT_ENABLED"`

	// If set to false, the node will *not* check whether the Cartesi machine hash from
	// the snapshot matches the hash in the Application contract.
	FeatureMachineHashCheckEnabled bool `mapstructure:"CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED"`

	// HTTP address for inspect.
	InspectAddress string `mapstructure:"CARTESI_INSPECT_ADDRESS"`

	// HTTP address for telemetry service.
	TelemetryAddress string `mapstructure:"CARTESI_TELEMETRY_ADDRESS"`

	// If set to true, the node will add colors to its log output.
	LogColor bool `mapstructure:"CARTESI_LOG_COLOR"`

	// One of "debug", "info", "warn", "error".
	LogLevel LogLevel `mapstructure:"CARTESI_LOG_LEVEL"`

	// Remote Cartesi Machine server log level.
	// One of "trace", "debug", "info", "warning", "error", "fatal".
	RemoteMachineLogLevel MachineLogLevel `mapstructure:"CARTESI_REMOTE_MACHINE_LOG_LEVEL"`

	// How many seconds the node will wait before querying the database for new inputs.
	AdvancerPollingInterval Duration `mapstructure:"CARTESI_ADVANCER_POLLING_INTERVAL"`

	// How many seconds the node will wait before querying the database for new claims.
	ClaimerPollingInterval Duration `mapstructure:"CARTESI_CLAIMER_POLLING_INTERVAL"`

	// How many seconds the retry policy will wait between retries.
	EvmReaderRetryPolicyMaxDelay Duration `mapstructure:"CARTESI_EVM_READER_RETRY_POLICY_MAX_DELAY"`

	// How many times some functions should be retried after an error.
	EvmReaderRetryPolicyMaxRetries uint64 `mapstructure:"CARTESI_EVM_READER_RETRY_POLICY_MAX_RETRIES"`

	// How many seconds the node expects services take initializing before aborting.
	MaxStartupTime Duration `mapstructure:"CARTESI_MAX_STARTUP_TIME"`

	// How many seconds the node will wait before trying to finish epochs for all applications.
	ValidatorPollingInterval Duration `mapstructure:"CARTESI_VALIDATOR_POLLING_INTERVAL"`

	// Path to the directory where the snapshots will be written.
	SnapshotDir string `mapstructure:"CARTESI_SNAPSHOT_DIR"`
}

func SetDefaults() {
	// Set defaults based on the TOML definitions.

	// no default for CARTESI_AUTH_AWS_KMS_KEY_ID

	// no default for CARTESI_AUTH_AWS_KMS_REGION

	viper.SetDefault(AUTH_KIND, "mnemonic")

	// no default for CARTESI_AUTH_MNEMONIC

	viper.SetDefault(AUTH_MNEMONIC_ACCOUNT_INDEX, "0")

	// no default for CARTESI_AUTH_MNEMONIC_FILE

	// no default for CARTESI_AUTH_PRIVATE_KEY

	// no default for CARTESI_AUTH_PRIVATE_KEY_FILE

	viper.SetDefault(BLOCKCHAIN_DEFAULT_BLOCK, "finalized")

	// no default for CARTESI_BLOCKCHAIN_HTTP_ENDPOINT

	// no default for CARTESI_BLOCKCHAIN_ID

	viper.SetDefault(BLOCKCHAIN_LEGACY_ENABLED, "false")

	viper.SetDefault(BLOCKCHAIN_SUBSCRIPTION_TIMEOUT, "60")

	// no default for CARTESI_BLOCKCHAIN_WS_ENDPOINT

	// no default for CARTESI_CONTRACTS_APPLICATION_FACTORY_ADDRESS

	// no default for CARTESI_CONTRACTS_AUTHORITY_FACTORY_ADDRESS

	// no default for CARTESI_CONTRACTS_INPUT_BOX_ADDRESS

	// no default for CARTESI_CONTRACTS_INPUT_BOX_DEPLOYMENT_BLOCK_NUMBER

	// no default for CARTESI_CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS

	viper.SetDefault(DATABASE_CONNECTION, "")

	viper.SetDefault(FEATURE_CLAIM_SUBMISSION_ENABLED, "true")

	viper.SetDefault(FEATURE_INPUT_READER_ENABLED, "true")

	viper.SetDefault(FEATURE_INSPECT_ENABLED, "true")

	viper.SetDefault(FEATURE_MACHINE_HASH_CHECK_ENABLED, "true")

	viper.SetDefault(INSPECT_ADDRESS, ":10012")

	// no default for CARTESI_TELEMETRY_ADDRESS

	viper.SetDefault(LOG_COLOR, "true")

	viper.SetDefault(LOG_LEVEL, "info")

	viper.SetDefault(REMOTE_MACHINE_LOG_LEVEL, "info")

	viper.SetDefault(ADVANCER_POLLING_INTERVAL, "3")

	viper.SetDefault(CLAIMER_POLLING_INTERVAL, "3")

	viper.SetDefault(EVM_READER_RETRY_POLICY_MAX_DELAY, "3")

	viper.SetDefault(EVM_READER_RETRY_POLICY_MAX_RETRIES, "3")

	viper.SetDefault(MAX_STARTUP_TIME, "15")

	viper.SetDefault(VALIDATOR_POLLING_INTERVAL, "3")

	viper.SetDefault(SNAPSHOT_DIR, "/var/lib/cartesi-rollups-node/snapshots")

}

// Load reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func Load() (*Config, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg Config
	var err error
	// For each env, perform conversion using the appropriate conversion function.

	cfg.BlockchainDefaultBlock, err = GetBlockchainDefaultBlock()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.BlockchainHttpEndpoint, err = GetBlockchainHttpEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.BlockchainId, err = GetBlockchainId()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.BlockchainLegacyEnabled, err = GetBlockchainLegacyEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.BlockchainSubscriptionTimeout, err = GetBlockchainSubscriptionTimeout()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.BlockchainWsEndpoint, err = GetBlockchainWsEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.ContractsInputBoxAddress, err = GetContractsInputBoxAddress()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.ContractsInputBoxDeploymentBlockNumber, err = GetContractsInputBoxDeploymentBlockNumber()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.DatabaseConnection, err = GetDatabaseConnection()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.FeatureClaimSubmissionEnabled, err = GetFeatureClaimSubmissionEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.FeatureInputReaderEnabled, err = GetFeatureInputReaderEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.FeatureInspectEnabled, err = GetFeatureInspectEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.FeatureMachineHashCheckEnabled, err = GetFeatureMachineHashCheckEnabled()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.InspectAddress, err = GetInspectAddress()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.RemoteMachineLogLevel, err = GetRemoteMachineLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.AdvancerPollingInterval, err = GetAdvancerPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.ClaimerPollingInterval, err = GetClaimerPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.EvmReaderRetryPolicyMaxDelay, err = GetEvmReaderRetryPolicyMaxDelay()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.EvmReaderRetryPolicyMaxRetries, err = GetEvmReaderRetryPolicyMaxRetries()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.ValidatorPollingInterval, err = GetValidatorPollingInterval()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}

	cfg.SnapshotDir, err = GetSnapshotDir()
	if err != nil && err != ErrNotDefined {
		return nil, err
	}
	return &cfg, nil
}

// GetAuthAwsKmsKeyId returns the value for the environment variable CARTESI_AUTH_AWS_KMS_KEY_ID.
func GetAuthAwsKmsKeyId() (RedactedString, error) {
	s := viper.GetString(AUTH_AWS_KMS_KEY_ID)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_AWS_KMS_KEY_ID, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), ErrNotDefined
}

// GetAuthAwsKmsRegion returns the value for the environment variable CARTESI_AUTH_AWS_KMS_REGION.
func GetAuthAwsKmsRegion() (RedactedString, error) {
	s := viper.GetString(AUTH_AWS_KMS_REGION)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_AWS_KMS_REGION, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), ErrNotDefined
}

// GetAuthKind returns the value for the environment variable CARTESI_AUTH_KIND.
func GetAuthKind() (AuthKind, error) {
	s := viper.GetString(AUTH_KIND)
	if s != "" {
		v, err := toAuthKind(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_KIND, err)
		}
		return v, nil
	}
	return notDefinedAuthKind(), ErrNotDefined
}

// GetAuthMnemonic returns the value for the environment variable CARTESI_AUTH_MNEMONIC.
func GetAuthMnemonic() (RedactedString, error) {
	s := viper.GetString(AUTH_MNEMONIC)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), ErrNotDefined
}

// GetAuthMnemonicAccountIndex returns the value for the environment variable CARTESI_AUTH_MNEMONIC_ACCOUNT_INDEX.
func GetAuthMnemonicAccountIndex() (RedactedUint, error) {
	s := viper.GetString(AUTH_MNEMONIC_ACCOUNT_INDEX)
	if s != "" {
		v, err := toRedactedUint(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC_ACCOUNT_INDEX, err)
		}
		return v, nil
	}
	return notDefinedRedactedUint(), ErrNotDefined
}

// GetAuthMnemonicFile returns the value for the environment variable CARTESI_AUTH_MNEMONIC_FILE.
func GetAuthMnemonicFile() (string, error) {
	s := viper.GetString(AUTH_MNEMONIC_FILE)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC_FILE, err)
		}
		return v, nil
	}
	return notDefinedstring(), ErrNotDefined
}

// GetAuthPrivateKey returns the value for the environment variable CARTESI_AUTH_PRIVATE_KEY.
func GetAuthPrivateKey() (RedactedString, error) {
	s := viper.GetString(AUTH_PRIVATE_KEY)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_PRIVATE_KEY, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), ErrNotDefined
}

// GetAuthPrivateKeyFile returns the value for the environment variable CARTESI_AUTH_PRIVATE_KEY_FILE.
func GetAuthPrivateKeyFile() (string, error) {
	s := viper.GetString(AUTH_PRIVATE_KEY_FILE)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_PRIVATE_KEY_FILE, err)
		}
		return v, nil
	}
	return notDefinedstring(), ErrNotDefined
}

// GetBlockchainDefaultBlock returns the value for the environment variable CARTESI_BLOCKCHAIN_DEFAULT_BLOCK.
func GetBlockchainDefaultBlock() (DefaultBlock, error) {
	s := viper.GetString(BLOCKCHAIN_DEFAULT_BLOCK)
	if s != "" {
		v, err := toDefaultBlock(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_DEFAULT_BLOCK, err)
		}
		return v, nil
	}
	return notDefinedDefaultBlock(), ErrNotDefined
}

// GetBlockchainHttpEndpoint returns the value for the environment variable CARTESI_BLOCKCHAIN_HTTP_ENDPOINT.
func GetBlockchainHttpEndpoint() (URL, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_ENDPOINT)
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_ENDPOINT, err)
		}
		return v, nil
	}
	return notDefinedURL(), ErrNotDefined
}

// GetBlockchainId returns the value for the environment variable CARTESI_BLOCKCHAIN_ID.
func GetBlockchainId() (uint64, error) {
	s := viper.GetString(BLOCKCHAIN_ID)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_ID, err)
		}
		return v, nil
	}
	return notDefineduint64(), ErrNotDefined
}

// GetBlockchainLegacyEnabled returns the value for the environment variable CARTESI_BLOCKCHAIN_LEGACY_ENABLED.
func GetBlockchainLegacyEnabled() (bool, error) {
	s := viper.GetString(BLOCKCHAIN_LEGACY_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_LEGACY_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), ErrNotDefined
}

// GetBlockchainSubscriptionTimeout returns the value for the environment variable CARTESI_BLOCKCHAIN_SUBSCRIPTION_TIMEOUT.
func GetBlockchainSubscriptionTimeout() (uint64, error) {
	s := viper.GetString(BLOCKCHAIN_SUBSCRIPTION_TIMEOUT)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_SUBSCRIPTION_TIMEOUT, err)
		}
		return v, nil
	}
	return notDefineduint64(), ErrNotDefined
}

// GetBlockchainWsEndpoint returns the value for the environment variable CARTESI_BLOCKCHAIN_WS_ENDPOINT.
func GetBlockchainWsEndpoint() (URL, error) {
	s := viper.GetString(BLOCKCHAIN_WS_ENDPOINT)
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_WS_ENDPOINT, err)
		}
		return v, nil
	}
	return notDefinedURL(), ErrNotDefined
}

// GetContractsApplicationFactoryAddress returns the value for the environment variable CARTESI_CONTRACTS_APPLICATION_FACTORY_ADDRESS.
func GetContractsApplicationFactoryAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_APPLICATION_FACTORY_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_APPLICATION_FACTORY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), ErrNotDefined
}

// GetContractsAuthorityFactoryAddress returns the value for the environment variable CARTESI_CONTRACTS_AUTHORITY_FACTORY_ADDRESS.
func GetContractsAuthorityFactoryAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_AUTHORITY_FACTORY_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_AUTHORITY_FACTORY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), ErrNotDefined
}

// GetContractsInputBoxAddress returns the value for the environment variable CARTESI_CONTRACTS_INPUT_BOX_ADDRESS.
func GetContractsInputBoxAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_INPUT_BOX_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_INPUT_BOX_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), ErrNotDefined
}

// GetContractsInputBoxDeploymentBlockNumber returns the value for the environment variable CARTESI_CONTRACTS_INPUT_BOX_DEPLOYMENT_BLOCK_NUMBER.
func GetContractsInputBoxDeploymentBlockNumber() (uint64, error) {
	s := viper.GetString(CONTRACTS_INPUT_BOX_DEPLOYMENT_BLOCK_NUMBER)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_INPUT_BOX_DEPLOYMENT_BLOCK_NUMBER, err)
		}
		return v, nil
	}
	return notDefineduint64(), ErrNotDefined
}

// GetContractsSelfHostedApplicationFactoryAddress returns the value for the environment variable CARTESI_CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS.
func GetContractsSelfHostedApplicationFactoryAddress() (Address, error) {
	s := viper.GetString(CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CONTRACTS_SELF_HOSTED_APPLICATION_FACTORY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), ErrNotDefined
}

// GetDatabaseConnection returns the value for the environment variable CARTESI_DATABASE_CONNECTION.
func GetDatabaseConnection() (URL, error) {
	s := viper.GetString(DATABASE_CONNECTION)
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", DATABASE_CONNECTION, err)
		}
		return v, nil
	}
	return notDefinedURL(), ErrNotDefined
}

// GetFeatureClaimSubmissionEnabled returns the value for the environment variable CARTESI_FEATURE_CLAIM_SUBMISSION_ENABLED.
func GetFeatureClaimSubmissionEnabled() (bool, error) {
	s := viper.GetString(FEATURE_CLAIM_SUBMISSION_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_CLAIM_SUBMISSION_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), ErrNotDefined
}

// GetFeatureInputReaderEnabled returns the value for the environment variable CARTESI_FEATURE_INPUT_READER_ENABLED.
func GetFeatureInputReaderEnabled() (bool, error) {
	s := viper.GetString(FEATURE_INPUT_READER_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_INPUT_READER_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), ErrNotDefined
}

// GetFeatureInspectEnabled returns the value for the environment variable CARTESI_FEATURE_INSPECT_ENABLED.
func GetFeatureInspectEnabled() (bool, error) {
	s := viper.GetString(FEATURE_INSPECT_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_INSPECT_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), ErrNotDefined
}

// GetFeatureMachineHashCheckEnabled returns the value for the environment variable CARTESI_FEATURE_MACHINE_HASH_CHECK_ENABLED.
func GetFeatureMachineHashCheckEnabled() (bool, error) {
	s := viper.GetString(FEATURE_MACHINE_HASH_CHECK_ENABLED)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", FEATURE_MACHINE_HASH_CHECK_ENABLED, err)
		}
		return v, nil
	}
	return notDefinedbool(), ErrNotDefined
}

// GetInspectAddress returns the value for the environment variable CARTESI_INSPECT_ADDRESS.
func GetInspectAddress() (string, error) {
	s := viper.GetString(INSPECT_ADDRESS)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", INSPECT_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedstring(), ErrNotDefined
}

// GetTelemetryAddress returns the value for the environment variable CARTESI_TELEMETRY_ADDRESS.
func GetTelemetryAddress() (string, error) {
	s := viper.GetString(TELEMETRY_ADDRESS)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", TELEMETRY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedstring(), ErrNotDefined
}

// GetLogColor returns the value for the environment variable CARTESI_LOG_COLOR.
func GetLogColor() (bool, error) {
	s := viper.GetString(LOG_COLOR)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", LOG_COLOR, err)
		}
		return v, nil
	}
	return notDefinedbool(), ErrNotDefined
}

// GetLogLevel returns the value for the environment variable CARTESI_LOG_LEVEL.
func GetLogLevel() (LogLevel, error) {
	s := viper.GetString(LOG_LEVEL)
	if s != "" {
		v, err := toLogLevel(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", LOG_LEVEL, err)
		}
		return v, nil
	}
	return notDefinedLogLevel(), ErrNotDefined
}

// GetRemoteMachineLogLevel returns the value for the environment variable CARTESI_REMOTE_MACHINE_LOG_LEVEL.
func GetRemoteMachineLogLevel() (MachineLogLevel, error) {
	s := viper.GetString(REMOTE_MACHINE_LOG_LEVEL)
	if s != "" {
		v, err := toMachineLogLevel(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", REMOTE_MACHINE_LOG_LEVEL, err)
		}
		return v, nil
	}
	return notDefinedMachineLogLevel(), ErrNotDefined
}

// GetAdvancerPollingInterval returns the value for the environment variable CARTESI_ADVANCER_POLLING_INTERVAL.
func GetAdvancerPollingInterval() (Duration, error) {
	s := viper.GetString(ADVANCER_POLLING_INTERVAL)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", ADVANCER_POLLING_INTERVAL, err)
		}
		return v, nil
	}
	return notDefinedDuration(), ErrNotDefined
}

// GetClaimerPollingInterval returns the value for the environment variable CARTESI_CLAIMER_POLLING_INTERVAL.
func GetClaimerPollingInterval() (Duration, error) {
	s := viper.GetString(CLAIMER_POLLING_INTERVAL)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", CLAIMER_POLLING_INTERVAL, err)
		}
		return v, nil
	}
	return notDefinedDuration(), ErrNotDefined
}

// GetEvmReaderRetryPolicyMaxDelay returns the value for the environment variable CARTESI_EVM_READER_RETRY_POLICY_MAX_DELAY.
func GetEvmReaderRetryPolicyMaxDelay() (Duration, error) {
	s := viper.GetString(EVM_READER_RETRY_POLICY_MAX_DELAY)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", EVM_READER_RETRY_POLICY_MAX_DELAY, err)
		}
		return v, nil
	}
	return notDefinedDuration(), ErrNotDefined
}

// GetEvmReaderRetryPolicyMaxRetries returns the value for the environment variable CARTESI_EVM_READER_RETRY_POLICY_MAX_RETRIES.
func GetEvmReaderRetryPolicyMaxRetries() (uint64, error) {
	s := viper.GetString(EVM_READER_RETRY_POLICY_MAX_RETRIES)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", EVM_READER_RETRY_POLICY_MAX_RETRIES, err)
		}
		return v, nil
	}
	return notDefineduint64(), ErrNotDefined
}

// GetMaxStartupTime returns the value for the environment variable CARTESI_MAX_STARTUP_TIME.
func GetMaxStartupTime() (Duration, error) {
	s := viper.GetString(MAX_STARTUP_TIME)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", MAX_STARTUP_TIME, err)
		}
		return v, nil
	}
	return notDefinedDuration(), ErrNotDefined
}

// GetValidatorPollingInterval returns the value for the environment variable CARTESI_VALIDATOR_POLLING_INTERVAL.
func GetValidatorPollingInterval() (Duration, error) {
	s := viper.GetString(VALIDATOR_POLLING_INTERVAL)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", VALIDATOR_POLLING_INTERVAL, err)
		}
		return v, nil
	}
	return notDefinedDuration(), ErrNotDefined
}

// GetSnapshotDir returns the value for the environment variable CARTESI_SNAPSHOT_DIR.
func GetSnapshotDir() (string, error) {
	s := viper.GetString(SNAPSHOT_DIR)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", SNAPSHOT_DIR, err)
		}
		return v, nil
	}
	return notDefinedstring(), ErrNotDefined
}

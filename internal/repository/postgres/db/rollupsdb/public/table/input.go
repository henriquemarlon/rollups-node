//
// Code generated by go-jet DO NOT EDIT.
//
// WARNING: Changes to this file may cause incorrect behavior
// and will be lost if the code is regenerated
//

package table

import (
	"github.com/go-jet/jet/v2/postgres"
)

var Input = newInputTable("public", "input", "")

type inputTable struct {
	postgres.Table

	// Columns
	EpochApplicationID   postgres.ColumnInteger
	EpochIndex           postgres.ColumnFloat
	Index                postgres.ColumnFloat
	BlockNumber          postgres.ColumnFloat
	RawData              postgres.ColumnString
	Status               postgres.ColumnString
	MachineHash          postgres.ColumnString
	OutputsHash          postgres.ColumnString
	TransactionReference postgres.ColumnString
	SnapshotURI          postgres.ColumnString
	CreatedAt            postgres.ColumnTimestampz
	UpdatedAt            postgres.ColumnTimestampz

	AllColumns     postgres.ColumnList
	MutableColumns postgres.ColumnList
}

type InputTable struct {
	inputTable

	EXCLUDED inputTable
}

// AS creates new InputTable with assigned alias
func (a InputTable) AS(alias string) *InputTable {
	return newInputTable(a.SchemaName(), a.TableName(), alias)
}

// Schema creates new InputTable with assigned schema name
func (a InputTable) FromSchema(schemaName string) *InputTable {
	return newInputTable(schemaName, a.TableName(), a.Alias())
}

// WithPrefix creates new InputTable with assigned table prefix
func (a InputTable) WithPrefix(prefix string) *InputTable {
	return newInputTable(a.SchemaName(), prefix+a.TableName(), a.TableName())
}

// WithSuffix creates new InputTable with assigned table suffix
func (a InputTable) WithSuffix(suffix string) *InputTable {
	return newInputTable(a.SchemaName(), a.TableName()+suffix, a.TableName())
}

func newInputTable(schemaName, tableName, alias string) *InputTable {
	return &InputTable{
		inputTable: newInputTableImpl(schemaName, tableName, alias),
		EXCLUDED:   newInputTableImpl("", "excluded", ""),
	}
}

func newInputTableImpl(schemaName, tableName, alias string) inputTable {
	var (
		EpochApplicationIDColumn   = postgres.IntegerColumn("epoch_application_id")
		EpochIndexColumn           = postgres.FloatColumn("epoch_index")
		IndexColumn                = postgres.FloatColumn("index")
		BlockNumberColumn          = postgres.FloatColumn("block_number")
		RawDataColumn              = postgres.StringColumn("raw_data")
		StatusColumn               = postgres.StringColumn("status")
		MachineHashColumn          = postgres.StringColumn("machine_hash")
		OutputsHashColumn          = postgres.StringColumn("outputs_hash")
		TransactionReferenceColumn = postgres.StringColumn("transaction_reference")
		SnapshotURIColumn          = postgres.StringColumn("snapshot_uri")
		CreatedAtColumn            = postgres.TimestampzColumn("created_at")
		UpdatedAtColumn            = postgres.TimestampzColumn("updated_at")
		allColumns                 = postgres.ColumnList{EpochApplicationIDColumn, EpochIndexColumn, IndexColumn, BlockNumberColumn, RawDataColumn, StatusColumn, MachineHashColumn, OutputsHashColumn, TransactionReferenceColumn, SnapshotURIColumn, CreatedAtColumn, UpdatedAtColumn}
		mutableColumns             = postgres.ColumnList{EpochIndexColumn, BlockNumberColumn, RawDataColumn, StatusColumn, MachineHashColumn, OutputsHashColumn, TransactionReferenceColumn, SnapshotURIColumn, CreatedAtColumn, UpdatedAtColumn}
	)

	return inputTable{
		Table: postgres.NewTable(schemaName, tableName, alias, allColumns...),

		//Columns
		EpochApplicationID:   EpochApplicationIDColumn,
		EpochIndex:           EpochIndexColumn,
		Index:                IndexColumn,
		BlockNumber:          BlockNumberColumn,
		RawData:              RawDataColumn,
		Status:               StatusColumn,
		MachineHash:          MachineHashColumn,
		OutputsHash:          OutputsHashColumn,
		TransactionReference: TransactionReferenceColumn,
		SnapshotURI:          SnapshotURIColumn,
		CreatedAt:            CreatedAtColumn,
		UpdatedAt:            UpdatedAtColumn,

		AllColumns:     allColumns,
		MutableColumns: mutableColumns,
	}
}
